"use strict";
var Prelude = require("../Prelude");
var Control_Monad_Eff = require("../Control.Monad.Eff");
var Control_Monad_Eff_Random = require("../Control.Monad.Eff.Random");
var Data_Int = require("../Data.Int");
var Data_Maybe = require("../Data.Maybe");
var $$Math = require("../Math");
var Partial_Unsafe = require("../Partial.Unsafe");
var Data_Show = require("../Data.Show");
var Data_Semigroup = require("../Data.Semigroup");
var Data_Eq = require("../Data.Eq");
var Data_Function = require("../Data.Function");
var Data_Semiring = require("../Data.Semiring");
var Control_Semigroupoid = require("../Control.Semigroupoid");
var Data_Ring = require("../Data.Ring");
var Data_EuclideanRing = require("../Data.EuclideanRing");
var Data_Functor = require("../Data.Functor");

/**
 *  | A seed for the linear congruential generator. We omit a `Semiring`
 *  | instance because there is no `zero` value, as 0 is not an acceptable
 *  | seed for the generator.
 */
var Seed = function (x) {
    return x;
};
var showSeed = new Data_Show.Show(function (v) {
    return "Seed " + Data_Show.show(Data_Show.showInt)(v);
});

/**
 *  | The minimum permissible Seed value.
 */
var seedMin = 1;
var runSeed = function (v) {
    return v;
};

/**
 *  | The *modulus*: a magic constant for the linear congruential generator.
 *  | It is equal to 2^31 - 1, a Mersenne prime. It is useful for this value to
 *  | be prime, because then the requirement of the initial seed being coprime
 *  | to the modulus is satisfied when the seed is between 1 and lcgN - 1.
 */
var lcgN = 2147483647;

/**
 *  | The *multiplier*: a magic constant for the linear congruential generator
 */
var lcgM = 48271;

/**
 *  | Perturb a seed value
 */
var lcgPerturb = function (d) {
    var go = function (n) {
        return Data_Function.apply(Partial_Unsafe.unsafePartial)(function (dictPartial) {
            return Data_Function.apply(Data_Maybe.fromJust(dictPartial))(Data_Function.apply(Data_Int.fromNumber)($$Math.remainder(Data_Int.toNumber(lcgM) * Data_Int.toNumber(n) + d)(Data_Int.toNumber(lcgN))));
        });
    };
    return function ($9) {
        return Seed(go(runSeed($9)));
    };
};

/**
 *  | The maximum permissible Seed value.
 */
var seedMax = lcgM - 1;

/**
 *  | The *increment*: a magic constant for the linear congruential generator
 */
var lcgC = 0;

/**
 *  | Step the linear congruential generator
 */
var lcgNext = lcgPerturb(Data_Int.toNumber(lcgC));
var eqSeed = new Data_Eq.Eq(function (v) {
    return function (v1) {
        return v === v1;
    };
});
var ensureBetween = function (min) {
    return function (max) {
        return function (n) {
            var rangeSize = max - min;
            return (n % rangeSize + rangeSize | 0) % rangeSize + min | 0;
        };
    };
};
var mkSeed = function (x) {
    return ensureBetween(seedMin)(seedMax)(x);
};

/**
 *  | Create a random seed
 */
var randomSeed = Data_Functor.map(Control_Monad_Eff.functorEff)(mkSeed)(Control_Monad_Eff_Random.randomInt(seedMin)(seedMax));
module.exports = {
    lcgC: lcgC, 
    lcgM: lcgM, 
    lcgN: lcgN, 
    lcgNext: lcgNext, 
    lcgPerturb: lcgPerturb, 
    mkSeed: mkSeed, 
    randomSeed: randomSeed, 
    runSeed: runSeed, 
    showSeed: showSeed, 
    eqSeed: eqSeed
};
