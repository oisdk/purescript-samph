"use strict";
var Prelude = require("../Prelude");
var Control_Alt = require("../Control.Alt");
var Text_Parsing_Parser = require("../Text.Parsing.Parser");
var Text_Parsing_Parser_String = require("../Text.Parsing.Parser.String");
var Text_Parsing_Parser_Token = require("../Text.Parsing.Parser.Token");
var Data_Identity = require("../Data.Identity");
var Data_Semigroup = require("../Data.Semigroup");

/**
 * ---------------------------------------------------------
 *  minimal language definition
 * ------------------------------------------------------
 *  | This is the most minimal token definition. It is recommended to use
 *  | this definition as the basis for other definitions. `emptyDef` has
 *  | no reserved names or operators, is case sensitive and doesn't accept
 *  | comments, identifiers or operators.
 */
var emptyDef = (function () {
    var op$prime = function (dictMonad) {
        return Text_Parsing_Parser_String.oneOf(dictMonad)([ ":", "!", "#", "$", "%", "&", "*", "+", ".", "/", "<", "=", ">", "?", "@", "\\", "^", "|", "-", "~" ]);
    };
    return {
        commentStart: "", 
        commentEnd: "", 
        commentLine: "", 
        nestedComments: true, 
        identStart: Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Token.letter(Data_Identity.monadIdentity))(Text_Parsing_Parser_String["char"](Data_Identity.monadIdentity)("_")), 
        identLetter: Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Token.alphaNum(Data_Identity.monadIdentity))(Text_Parsing_Parser_String.oneOf(Data_Identity.monadIdentity)([ "_", "'" ])), 
        opStart: op$prime(Data_Identity.monadIdentity), 
        opLetter: op$prime(Data_Identity.monadIdentity), 
        reservedOpNames: [  ], 
        reservedNames: [  ], 
        caseSensitive: true
    };
})();

/**
 * ---------------------------------------------------------
 *  Styles: haskellStyle, javaStyle
 * ---------------------------------------------------------
 *  | This is a minimal token definition for Haskell style languages. It
 *  | defines the style of comments, valid identifiers and case
 *  | sensitivity. It does not define any reserved words or operators.
 */
var haskellStyle = (function () {
    var op$prime = function (dictMonad) {
        return Text_Parsing_Parser_String.oneOf(dictMonad)([ ":", "!", "#", "$", "%", "&", "*", "+", ".", "/", "<", "=", ">", "?", "@", "\\", "^", "|", "-", "~" ]);
    };
    var $2 = {};
    for (var $3 in Text_Parsing_Parser_Token.unGenLanguageDef(emptyDef)) {
        if ((Text_Parsing_Parser_Token.unGenLanguageDef(emptyDef)).hasOwnProperty($3)) {
            $2[$3] = (Text_Parsing_Parser_Token.unGenLanguageDef(emptyDef))[$3];
        };
    };
    $2.commentStart = "{-";
    $2.commentEnd = "-}";
    $2.commentLine = "--";
    $2.nestedComments = true;
    $2.identStart = Text_Parsing_Parser_Token.letter(Data_Identity.monadIdentity);
    $2.identLetter = Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Token.alphaNum(Data_Identity.monadIdentity))(Text_Parsing_Parser_String.oneOf(Data_Identity.monadIdentity)([ "_", "'" ]));
    $2.opStart = op$prime(Data_Identity.monadIdentity);
    $2.opLetter = op$prime(Data_Identity.monadIdentity);
    $2.reservedOpNames = [  ];
    $2.reservedNames = [  ];
    $2.caseSensitive = true;
    return $2;
})();

/**
 *  | The language definition for the language Haskell98.
 */
var haskell98Def = (function () {
    var $4 = {};
    for (var $5 in Text_Parsing_Parser_Token.unGenLanguageDef(haskellStyle)) {
        if ((Text_Parsing_Parser_Token.unGenLanguageDef(haskellStyle)).hasOwnProperty($5)) {
            $4[$5] = (Text_Parsing_Parser_Token.unGenLanguageDef(haskellStyle))[$5];
        };
    };
    $4.reservedOpNames = [ "::", "..", "=", "\\", "|", "<-", "->", "@", "~", "=>" ];
    $4.reservedNames = [ "let", "in", "case", "of", "if", "then", "else", "data", "type", "class", "default", "deriving", "do", "import", "infix", "infixl", "infixr", "instance", "module", "newtype", "where", "primitive" ];
    return $4;
})();

/**
 *  | The language definition for the Haskell language.
 */
var haskellDef = (function () {
    var $7 = {};
    for (var $8 in haskell98Def) {
        if (haskell98Def.hasOwnProperty($8)) {
            $7[$8] = haskell98Def[$8];
        };
    };
    $7.identLetter = Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(haskell98Def.identLetter)(Text_Parsing_Parser_String["char"](Data_Identity.monadIdentity)("#"));
    $7.reservedNames = Data_Semigroup.append(Data_Semigroup.semigroupArray)(haskell98Def.reservedNames)([ "foreign", "import", "export", "primitive", "_ccall_", "_casm_", "forall" ]);
    return $7;
})();

/**
 *  -----------------------------------------------------------
 *  -- Haskell
 *  -----------------------------------------------------------
 *  | A lexer for the haskell language.
 */
var haskell = Text_Parsing_Parser_Token.makeTokenParser(Data_Identity.monadIdentity)(haskellDef);

/**
 *  | This is a minimal token definition for Java style languages. It
 *  | defines the style of comments, valid identifiers and case
 *  | sensitivity. It does not define any reserved words or operators.
 */
var javaStyle = (function () {
    var $9 = {};
    for (var $10 in Text_Parsing_Parser_Token.unGenLanguageDef(emptyDef)) {
        if ((Text_Parsing_Parser_Token.unGenLanguageDef(emptyDef)).hasOwnProperty($10)) {
            $9[$10] = (Text_Parsing_Parser_Token.unGenLanguageDef(emptyDef))[$10];
        };
    };
    $9.commentStart = "/*";
    $9.commentEnd = "*/";
    $9.commentLine = "//";
    $9.nestedComments = true;
    $9.identStart = Text_Parsing_Parser_Token.letter(Data_Identity.monadIdentity);
    $9.identLetter = Control_Alt.alt(Text_Parsing_Parser.altParserT(Data_Identity.monadIdentity))(Text_Parsing_Parser_Token.alphaNum(Data_Identity.monadIdentity))(Text_Parsing_Parser_String.oneOf(Data_Identity.monadIdentity)([ "_", "'" ]));
    $9.reservedNames = [  ];
    $9.reservedOpNames = [  ];
    $9.caseSensitive = false;
    return $9;
})();
module.exports = {
    emptyDef: emptyDef, 
    haskell: haskell, 
    haskellDef: haskellDef, 
    haskellStyle: haskellStyle, 
    javaStyle: javaStyle
};
